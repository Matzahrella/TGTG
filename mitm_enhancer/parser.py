import json
from typing import List, Dict, Any, Optional
from mitmproxy import io, http as mitmproxy_http # Renamed to avoid conflict with our model
from mitmproxy.exceptions import FlowReadException

from .models import HTTPFlow, Request, Response

def _get_content_type(headers: Dict[str, str]) -> Optional[str]:
    """Helper to get content-type from headers dict, case-insensitive."""
    for k, v in headers.items():
        if k.lower() == 'content-type':
            return v
    return None

def parse_flows(file_path: str) -> List[HTTPFlow]:
    """
    Parses a mitmproxy flow file and converts flows into HTTPFlow Pydantic models.

    Args:
        file_path: Path to the mitmproxy flow file.

    Returns:
        A list of HTTPFlow Pydantic model instances.
    """
    parsed_flow_models: List[HTTPFlow] = []

    try:
        with open(file_path, "rb") as f:
            reader = io.FlowReader(f)
            for flow in reader.stream():
                if not isinstance(flow, mitmproxy_http.HTTPFlow):
                    continue

                # Prepare request data
                request_headers_dict = {
                    k.decode('utf-8', 'replace'): v.decode('utf-8', 'replace') 
                    for k, v in flow.request.headers.fields
                }
                request_content_type_header = _get_content_type(request_headers_dict)
                
                request_body_data: Any
                if "application/json" in (request_content_type_header or ""):
                    try:
                        request_body_data = json.loads(flow.request.text)
                    except json.JSONDecodeError:
                        request_body_data = flow.request.content # Keep as bytes
                else:
                    request_body_data = flow.request.content # Keep as bytes

                request_model = Request(
                    timestamp_start=flow.request.timestamp_start,
                    method=flow.request.method,
                    url=flow.request.url,
                    headers=request_headers_dict,
                    body=request_body_data,
                    content_type=request_content_type_header
                )

                # Prepare response data (if present)
                response_model: Optional[Response] = None
                if flow.response:
                    response_headers_dict = {
                        k.decode('utf-8', 'replace'): v.decode('utf-8', 'replace') 
                        for k, v in flow.response.headers.fields
                    }
                    response_content_type_header = _get_content_type(response_headers_dict)

                    response_body_data: Any
                    if "application/json" in (response_content_type_header or ""):
                        try:
                            response_body_data = json.loads(flow.response.text)
                        except json.JSONDecodeError:
                            response_body_data = flow.response.content # Keep as bytes
                    else:
                        response_body_data = flow.response.content # Keep as bytes
                    
                    response_model = Response(
                        timestamp_end=flow.response.timestamp_end,
                        status_code=flow.response.status_code,
                        headers=response_headers_dict,
                        body=response_body_data,
                        content_type=response_content_type_header
                    )

                # Create HTTPFlow model instance
                # ID is generated by Pydantic default_factory
                # Annotation is empty by default
                http_flow_model = HTTPFlow(
                    request=request_model,
                    response=response_model,
                    client_conn_id=flow.client_conn.id if flow.client_conn else None,
                    server_conn_id=flow.server_conn.id if flow.server_conn else None,
                    timestamp_created=flow.timestamp_created
                )
                
                parsed_flow_models.append(http_flow_model)

    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
        raise
    except FlowReadException as e:
        print(f"Error: Could not read flows from {file_path}. Invalid format? Details: {e}")
        raise
    except Exception as e:
        print(f"An unexpected error occurred during parsing: {e}")
        raise

    return parsed_flow_models

if __name__ == '__main__':
    # This is a placeholder for basic testing.
    # To use this:
    # 1. Save a mitmproxy flow file (e.g., from `mitmdump -w flows.mitm`)
    # 2. Update the path below to point to your saved file.
    # 3. Run this script from the project root: `python -m mitm_enhancer.parser` (if models.py is in the same dir)
    #    or adjust python path if running directly.
    
    # Create a dummy models.py for this test if it's not found easily
    try:
        from models import HTTPFlow, Request, Response # For direct execution if models is in PYTHONPATH
    except ImportError:
        # A simple stub for testing if models.py is not directly accessible
        print("Warning: mitm_enhancer.models not found, using basic stubs for testing parser.py directly.")
        from pydantic import BaseModel
        class Request(BaseModel): timestamp_start: float; method: str; url: str; headers: Dict; body: Any; content_type: Optional[str] = None
        class Response(BaseModel): timestamp_end: float; status_code: int; headers: Dict; body: Any; content_type: Optional[str] = None
        class HTTPFlow(BaseModel): id: str = "test_id"; request: Request; response: Optional[Response] = None; annotation: str = ""; client_conn_id: Optional[str] = None; server_conn_id: Optional[str] = None; timestamp_created: Optional[float] = None
    
    # Create a dummy flow file for testing
    sample_flow_file = "test_flows.mitm"
    # This requires mitmproxy to be installed to *create* a flow file.
    # For now, we'll just simulate its existence for the FileNotFoundError test or if you manually create one.
    # You would typically generate this with: mitmdump -w test_flows.mitm
    # For this script, we'll just check if it exists.
    
    print(f"Attempting to parse '{sample_flow_file}' (if it exists)...")
    print("Note: This test is more effective if 'test_flows.mitm' is a valid mitmproxy file.")

    try:
        # Create an empty dummy file if it doesn't exist, so the parser can attempt to read it
        # The parser should handle empty or invalid flow files gracefully (FlowReadException)
        open(sample_flow_file, 'ab').close() # Ensure file exists, 'ab' to not truncate if it has content
        
        flows = parse_flows(sample_flow_file)
        if flows:
            print(f"\nSuccessfully parsed {len(flows)} flows into Pydantic models.")
            for i, flow_model in enumerate(flows):
                print(f"\n--- Flow Model {i+1} ---")
                print(f"  ID: {flow_model.id}")
                print(f"  Annotation: {flow_model.annotation}")
                print(f"  Timestamp Created: {flow_model.timestamp_created}")
                print(f"  Client Conn ID: {flow_model.client_conn_id}")
                print(f"  Server Conn ID: {flow_model.server_conn_id}")
                print(f"  Request URL: {flow_model.request.url}")
                print(f"  Request Content-Type: {flow_model.request.content_type}")
                if flow_model.response:
                    print(f"  Response Status: {flow_model.response.status_code}")
                    print(f"  Response Content-Type: {flow_model.response.content_type}")
                # To see full model: print(flow_model.model_dump_json(indent=2))
        elif not flows and open(sample_flow_file, 'rb').read(): # File exists and is not empty but no HTTPFlows
             print("No HTTP flows found in the file, or the file is valid but contains no parsable HTTP traffic.")
        else: # File was empty or parsing failed before HTTPFlow check
             print("No flows were parsed. The file might be empty, not a valid mitmproxy file, or contain no HTTP flows.")

    except FileNotFoundError:
        print(f"Test an aborted: The sample flow file '{sample_flow_file}' was not found. Please create it to test the parser.")
    except FlowReadException:
        print(f"Test an aborted: Could not read '{sample_flow_file}'. It might not be a valid mitmproxy file or is corrupted.")
    except Exception as e:
        print(f"An error occurred during the test run: {e}")
    finally:
        # Clean up dummy file if you want
        # import os
        # if os.path.exists(sample_flow_file) and os.path.getsize(sample_flow_file) == 0:
        #     os.remove(sample_flow_file)
        pass
